# item-eyes
ASP.NET Core project for inventory management

## Contents
- [Description](#description)
- [Models](#models)
- [Configuring EF Core](#configuring-ef-core)
- [Controllers / Views](#controllersviews)
- [API](#rest-api)
- [Future Considerations](#future-considerations)

![index](https://github.com/kellivan/ItemEyes/blob/main/screenshots/index.png)

## Description
This is a simple ASP.NET project created following Microsoft Documentaion site
for ASP.NET Core.

The project started as a Web API and has been expanded to include MVC.
ASP.NET allows for both to coexist, but ideally they should be seperately hosted.
They're grouped together in this project for convience and demonstration.
It was accomplished by utilizing the Areas folder for MVC and updating the Startup
configuration.

## Models

The original draft included four data models:
- Inventory
- Items
- Orders
- Locations

I quickly realized that a one-to-many Inventory join table was redundant, as the rows of the Items table
would work just as easily on its own. I then considered the Orders table, which I originally thought
was key, as it would allow for multiple items of the same type while still separating the entries.  But
just like the Inventory table before, it too was found redundant and easily replaceable with a single
column in the Items table.

This left me with two tables:
- Items
- Locations

![EFCore](https://github.com/kellivan/ItemEyes/blob/main/screenshots/efcore.png)

I was tempted at this point to consider whether or not the location data should just be
merged into the Items table as 2 to 3 more columns.  But I found that this would lead to
a significant amount of duplicate columns that would otherwise just be single id numbers.  So I
decided to stop worrying about the data models and move on to the next phase.

## Configuring EF Core
After creating the class files for the data models, I went about setting up my project for
EF Core.  This step includes installing the NuGet packages for EF Core, setting up the project files
to use a database (EF Core InMemory database was used here), and creating a class for the
Entity Framework Database Context.  In addition, since this is a demo project, it was necessary to
supply demo data.  This was accomplished by creating an EF DbInitializer class.

## Controllers/Views

### Index
This is the landing page for the project.

### Items / (Details, Create, Edit, Delete)
These are scaffolded pages for CRUD operations for Item data.

Create and Edit had to be modified to work properly with data model.
In a perfect world, the data models would be set up so that the scaffolded item
works properly when autogenerated.

### Locations / (Details, Create, Edit, Delete)
These are scaffolded pages for CRUD operations for Location data.

### / api / *
These are controllers for the WebAPI access to the data. More info about the API in the following
sections.

## Rest API

### Development
This project began as a school assignment for a ASP.NET Rest API implementing some business logic,
and I expanded it to include MVC Web app components. After much diliberation,
I decided on an inventory tracker, as it would be simple enough to get started on, but still
complicated enough to have something to talk about here.

### Output
The Web API interfaces the LocalDb Database using EF Core and performs basic CRUD operations
on inventory items and their locations.  Some specialized actions have been configured to
implement order storage input and output, as well as provide multiple query options.
The .NET Template for Web API is preconfigured to use Swagger UI to demo builds. It looks like
this:

![Swagger1](https://github.com/kellivan/ItemEyes/blob/main/screenshots/api.png)

And this is how you can sandbox actions using the page:

![Swagger2](https://github.com/kellivan/ItemEyes/blob/main/screenshots/api-get.png)


Of course, you can call the api directly from the browser:

![api](https://github.com/kellivan/ItemEyes/blob/main/screenshots/api.gif)

### Scaffolding Controllers
Once setting up the database portion was complete, the next step was to create the controllers
for the two models that were established. Visual Studio makes this quick to start by generating
some boilerplate CRUD actions through scaffolding.  From there, the actions were added to and modified
to replicate inventory procedures.  Testing was now able to begin, and I discovered several key
aspects to Web API design that didn't overlap with the MVC experience I gained earlier.

The biggest difference I observed, outside of the lack of views, was that the HTTP actions in
the Web API were very particular with how they are called.  In order to overload these methods,
I had find ways that would cooperate with how the API worked.  There were a few ways to accomplish
this, with additional controllers or estabilishing routes in the startup file, but by far the
easiest and preferred way was simply use the Routing Bracket Syntax to specify unique
URI's for the various actions required.

## Identity
After everything else has been setup, a recent addition to the project was user account
authorization and authentication.  Microsoft provides this in ASP.NET with Identity, 
allowing us to scaffold in new pages for logging in, registration, logging out, etc...

For this first step, I restructured the scaffolded Identity Area to use MVC, since the
scoffolded item used Razor Pages by default.  This was to match the current structure
of the project.  I then did basic setup for the user database, which wasn't too different
from the Item databse setup.  I supplied it with an initial account, and setup a login page.

After that, the controllers were modified to require Authorization where necessary and
a special middleware class was added to do the same for the SwaggerUI page.

## Future Considerations
Plans for this project include adding more documentation so it better serves as a sample project.
Also adding functionality via controllers and adding new data models and/or expanding existing ones.

Further development of the Identity portion of the project is another possibility, as there
are many options that can be implemented.  Currently only logging in has been setup, and registration
would be the next step to add new users.  More complex options would be to allow for third-party
service assisted signup (linking an account with google, facebook, etc.). 

With the addition of accounts, the possibility of variable data access could be worth considering as
well.  This would allow to different types of accounts and different levels of functional actions
for each.

There is a known issue which occurs during operation with EF core, where
performing actions immediately (or a short time) after previous actions can cause threading issues.
This can be addressed by utilizing DbContextFactory to create seperate context threads for these
actions. This would also be a potential addition to this project.
